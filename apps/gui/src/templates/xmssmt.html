<!DOCTYPE html>
<html lang="en">
<head>
  {% from '_background_effects.html' import background_layer, background_rules %}
  {% from '_detail_styles.html' import detail_styles %}
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>{{ label }} - Details</title>
  <link rel="icon" href="/static/favicon.svg" type="image/svg+xml" sizes="any" />
  <link rel="mask-icon" href="/static/favicon.svg" color="#1fb6b8" />
  <link rel="apple-touch-icon" href="/static/Images/pqc-bench-logo.png" />
  <meta name="theme-color" content="#0b0f14" />
  <style>
    {{ detail_styles() | safe }}
    {{ background_rules() | safe }}
  </style>
  <!-- MathJax for LaTeX-style math -->
  <script async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
</head>
<body>
  {{ background_layer() }}
  <main class="detail-shell">
    <div class="island detail-hero">
      <div class="detail-hero__text">
        <span class="detail-hero__eyebrow">Algorithm Profile</span>
        <h1 class="detail-hero__title">{{ label }}</h1>
        <div class="detail-hero__meta">
          {% if kind %}<span class="detail-pill">{{ kind }}</span>{% endif %}
        </div>
        <p class="detail-hero__lead">
          {{ hero_lead or ('Explore the design, math, and security posture of ' ~ label ~ ' in depth.') }}
        </p>
      </div>
      <div class="detail-hero__actions">
        <a href="/" class="btn btn-soft">Back to home</a>
        <a href="#overview" class="btn btn-ghost">Jump to overview</a>
      </div>
    </div>

  <div class="island">
    <h2>About</h2>
    <p class="muted">
      {{ about or 'This page explains the eXtended Merkle Signature Scheme (XMSS) and its multi-tree variant XMSS^MT in depth: origins, design, math, parameters, algorithms, security issues (including state management), and practical considerations—with references.' }}
    </p>
    <div class="toc muted">
      <span class="chip"><a href="#history">Origins & history</a></span>
      <span class="chip"><a href="#overview">Design overview</a></span>
      <span class="chip"><a href="#math">Mathematical setting</a></span>
      <span class="chip"><a href="#params">Parameter sets</a></span>
      <span class="chip"><a href="#algorithms">Algorithms</a></span>
      <span class="chip"><a href="#security">Security</a></span>
      <span class="chip"><a href="#impl">Implementation notes</a></span>
      <span class="chip"><a href="#proscons">Pros & cons</a></span>
      <span class="chip"><a href="#references">References</a></span>
    </div>
  </div>

  <div class="island" id="history">
    <h2>Origins & history</h2>
    <p class="muted">
      <strong>XMSS</strong> is a stateful, hash-based signature standardized by the IETF as RFC&nbsp;8391 (2018) [1], defining WOTS+, single-tree XMSS, and multi-tree <strong>XMSS<sup>MT</sup></strong>. NIST later profiled XMSS/XMSS<sup>MT</sup> for federal use in SP&nbsp;800-208 (2020), approving concrete parameter sets and giving deployment guidance for state management [2].
    </p>
  </div>

  <div class="island" id="overview">
    <h2>Design overview</h2>
    <p class="muted">
      XMSS composes three ideas: a <em>Winternitz one-time signature</em> (WOTS+), an <em>L-tree</em> to compress the WOTS+ public key to one <span class="mono">n</span>-byte leaf, and a binary <em>Merkle tree</em> authenticating leaves to a long-term public root [1]. Each message consumes exactly one WOTS+ key (hence “stateful”). XMSS<sup>MT</sup> stacks multiple XMSS trees into a hypertree so upper layers sign lower-layer roots, extending capacity while keeping each tree height manageable [1], [2].
    </p>
  </div>

  <div class="island" id="math">
    <h2>Mathematical setting</h2>
    <p class="muted">
      Let \(n\) be the hash security parameter (bytes) and \(w\in\{4,16\}\) the Winternitz parameter. WOTS+ comprises \(\mathrm{len}\) base-\(w\) chains with standard lengths
    </p>
    <p class="mono">
      \( \mathrm{len}_1=\left\lceil \dfrac{8n}{\log_2 w}\right\rceil,\quad
         \mathrm{len}_2=\left\lfloor \dfrac{\log_2(\mathrm{len}_1 (w-1))}{\log_2 w}\right\rfloor+1,\quad
         \mathrm{len}=\mathrm{len}_1+\mathrm{len}_2 \) [1].
    </p>
    <p class="muted">
      The WOTS+ chaining function iterates a keyed hash \(F\) with ADRS-tweaked bitmasks; XMSS uses keyed, randomized hashing \(H\) (with two bitmasks) and a randomized message hash \(H_{\text{msg}}\) for domain separation and multi-target resistance [1], [2]. Leaves are L-tree compressions of WOTS+ public keys; the public key is \((\text{root}, \text{SEED})\) [1].
    </p>
  </div>

  <div class="island" id="params">
    <h2>Parameter sets</h2>
    <p class="muted note">
      NIST SP&nbsp;800-208 approves XMSS/XMSS<sup>MT</sup> parameter sets using SHA-256 or SHAKE256 with 192-/256-bit output security and \(w=16\) [2]. Below are representative entries; see the cited tables for the full lists [2].
    </p>
    <div class="grid-2">
      <div>
        <h3>XMSS (single-tree)</h3>
        <table>
          <thead><tr><th>Parameter set</th><th>n</th><th>w</th><th>len</th><th>h</th></tr></thead>
          <tbody>
            <tr><td>XMSS-SHA2_10_192</td><td>24</td><td>16</td><td>51</td><td>10</td></tr>
            <tr><td>XMSS-SHA2_16_192</td><td>24</td><td>16</td><td>51</td><td>16</td></tr>
            <tr><td>XMSS-SHA2_20_192</td><td>24</td><td>16</td><td>51</td><td>20</td></tr>
            <tr><td>XMSS-SHAKE256_10_256</td><td>32</td><td>16</td><td>67</td><td>10</td></tr>
            <tr><td>XMSS-SHAKE256_16_256</td><td>32</td><td>16</td><td>67</td><td>16</td></tr>
            <tr><td>XMSS-SHAKE256_20_256</td><td>32</td><td>16</td><td>67</td><td>20</td></tr>
          </tbody>
        </table>
      </div>
      <div>
        <h3>XMSS<sup>MT</sup> (multi-tree)</h3>
        <table>
          <thead><tr><th>Parameter set</th><th>n</th><th>w</th><th>len</th><th>h</th><th>d</th></tr></thead>
          <tbody>
            <tr><td>XMSSMT-SHA2_20/2_256</td><td>32</td><td>16</td><td>67</td><td>20</td><td>2</td></tr>
            <tr><td>XMSSMT-SHA2_60/3_256</td><td>32</td><td>16</td><td>67</td><td>60</td><td>3</td></tr>
            <tr><td>XMSSMT-SHA2_60/12_192</td><td>24</td><td>16</td><td>51</td><td>60</td><td>12</td></tr>
            <tr><td>XMSSMT-SHAKE256_40/8_256</td><td>32</td><td>16</td><td>67</td><td>40</td><td>8</td></tr>
          </tbody>
        </table>
        <p class="muted" style="margin-top:.5rem;">Function bindings (F, H, H<sub>msg</sub>, PRF, PRF<sub>keygen</sub>) and full tables are given in SP&nbsp;800-208 §5.1–§5.4 [2].</p>
      </div>
    </div>
    <p class="muted note">
      Signature lengths: for XMSS, \( |\sigma| = 4 + n + (\mathrm{len}+h)\,n \); for XMSS<sup>MT</sup>, \( |\sigma| = \lceil h/8 \rceil + n + (h + d\,\mathrm{len})\,n \) [1], [2].
    </p>
  </div>

  <div class="island" id="algorithms">
    <h2>Algorithms</h2>

    <h3>Key generation (single-tree)</h3>
    <ol class="muted">
      <li>Sample \(\mathsf{SEED}\) and derive ADRS-tweaked keys/bitmasks via \(\mathrm{PRF}(\mathsf{SEED}, \mathrm{ADRS})\) [1].</li>
      <li>For each leaf \(i\in\{0,\dots,2^h-1\}\), derive a WOTS+ key pair; compress its public key with an L-tree to obtain a leaf [1].</li>
      <li>Hash leaves pairwise with randomized \(H\) to compute internal nodes up to the root \(\mathsf{root}\) [1].</li>
      <li>Public key: \((\mathsf{root},\mathsf{SEED})\) [1].</li>
    </ol>

    <h3>Signing (XMSS)</h3>
    <ol class="muted">
      <li>Set \( \mathsf{idx\_sig}\leftarrow\mathsf{idx}\); compute per-signature randomness \( r \leftarrow \mathrm{PRF}(\mathsf{SK\_PRF}, \mathrm{ADRS}) \) [1].</li>
      <li>Compute randomized digest \( M' = H_{\text{msg}}( r \,\|\, \mathsf{root} \,\|\, \mathrm{toByte}(\mathsf{idx\_sig}, n),\, M ) \) [1].</li>
      <li>Produce WOTS+ signature \( \sigma_{\text{WOTS}} \) on \( M' \) with the \( \mathsf{idx\_sig} \) key; include the authentication path [1].</li>
      <li>Output \( \sigma = (\mathsf{idx\_sig}, r, \sigma_{\text{WOTS}}, \text{AuthPath}) \) [1].</li>
    </ol>

    <h3>Verification (XMSS)</h3>
    <ol class="muted">
      <li>Recompute \( M' \) as above; recover the WOTS+ public key from \( \sigma_{\text{WOTS}} \) and \( M' \); compress via L-tree to the leaf; climb the AuthPath to reconstruct \( \hat{\mathsf{root}} \); accept iff \( \hat{\mathsf{root}} = \mathsf{root} \) [1].</li>
    </ol>

    <h3>XMSS<sup>MT</sup> (multi-tree)</h3>
    <p class="muted">
      A hypertree of total height \(h\) is split into \(d\) layers; the bottom layer signs messages, while each upper layer signs the child root. The signature concatenates \(d\) reduced XMSS signatures plus \((\mathsf{idx\_sig}, r)\) [1], [2].
    </p>
  </div>

  <div class="island" id="security">
    <h2>Security at a glance</h2>
    <ul class="muted">
      <li><b>Assumptions:</b> collision, preimage, and second-preimage resistance of the underlying hash; proofs and exact syntax in RFC&nbsp;8391 [1], profiled by NIST SP&nbsp;800-208 [2].</li>
      <li><b>Randomized hashing & domain separation:</b> keyed \(H\) with two bitmasks and \(H_{\text{msg}}\) with \((r,\mathsf{root},\mathsf{idx\_sig})\) to prevent multi-target issues [1].</li>
      <li><b>Statefulness:</b> each WOTS+ key must be used once; NIST requires persisting the incremented index before releasing a signature and recommends controlled environments/HSMs [2].</li>
      <li><b>Capacity:</b> XMSS signs up to \(2^h\) messages per key; XMSS<sup>MT</sup> increases capacity via \(d\) layers [1], [2].</li>
    </ul>
  </div>

  <div class="island" id="impl">
    <h2>Implementation notes</h2>
    <ul class="muted">
      <li><b>BDS traversal:</b> generate authentication paths with \(O(h)\) storage and efficient updates (standard XMSS practice) [1].</li>
      <li><b>Seeded keygen:</b> derive WOTS+ private keys from a seed to reduce SK storage; follow the RFC’s PRF/ADRS usage [1].</li>
      <li><b>SP&nbsp;800-208 profile:</b> use approved parameter sets (SHA-256/SHAKE256; 192/256-bit security) and enforce non-export of secret keys and robust index persistence [2].</li>
      <li><b>Deployment fit:</b> firmware/code signing and long-lived roots of trust where state can be strictly managed [2].</li>
    </ul>
  </div>

  <div class="island" id="proscons">
    <h2>Pros & cons</h2>
    <div class="grid-2">
      <div>
        <h3>Pros</h3>
        <ul class="muted">
          <li>Conservative, hash-only assumptions; quantum-resistant by design [1], [2].</li>
          <li>Smaller signatures than SPHINCS+ at comparable security (kB vs multi-kB/10s-kB) [2].</li>
          <li>Mature standardization with interoperable parameter sets (IETF + NIST) [1], [2].</li>
        </ul>
      </div>
      <div>
        <h3>Cons</h3>
        <ul class="muted">
          <li>State management is hard; key reuse is catastrophic [2].</li>
          <li>Signatures still relatively large vs many lattice schemes; throughput limited by tree traversal [1], [2].</li>
          <li>Operational requirements (HSM, index persistence) may complicate integration [2].</li>
        </ul>
      </div>
    </div>
  </div>

  <div class="island" id="references">
    <h2>References</h2>
    <ol class="refs muted">
      <li>[1] A. Hülsing, D. Butin, S. Gazdag, J. Rijneveld, and J. M. Schanck, “<i>XMSS: eXtended Merkle Signature Scheme</i>,” RFC 8391, Internet Engineering Task Force, May 2018. DOI: <a target="_blank" rel="noopener" href="https://doi.org/10.17487/RFC8391">10.17487/RFC8391</a>. Available: <a target="_blank" rel="noopener" href="https://www.rfc-editor.org/info/rfc8391">https://www.rfc-editor.org/info/rfc8391</a></li>
      <li>[2] D. A. Cooper <i>et&nbsp;al.</i>, “<i>NIST SP 800-208: Recommendation for Stateful Hash-Based Signature Schemes</i>,” National Institute of Standards and Technology, Nov. 2020. DOI: <a target="_blank" rel="noopener" href="https://doi.org/10.6028/NIST.SP.800-208">10.6028/NIST.SP.800-208</a>. Available: <a target="_blank" rel="noopener" href="https://csrc.nist.gov/pubs/sp/800/208/final">https://csrc.nist.gov/pubs/sp/800/208/final</a></li>
      <li>[3] A. Hülsing, “WOTS+: Shorter Signatures for Hash-Based Signature Schemes,” IACR ePrint 2017/965, 2017. Available: <a target="_blank" rel="noopener" href="https://eprint.iacr.org/2017/965.pdf">https://eprint.iacr.org/2017/965.pdf</a></li>
      <li>[4] H. Kosuge and H. Tanaka, “Simple and Memory-Efficient Signature Generation of XMSS/XMSSMT,” in <i>SAC 2021</i> (slides/extended), 2021. Available: <a target="_blank" rel="noopener" href="https://www.ece.uvic.ca/~raltawy/SAC2021/9.pdf">https://www.ece.uvic.ca/~raltawy/SAC2021/9.pdf</a></li>
      <li>[5] A. Hülsing, J. Buchmann, and D. Martínez, “XMSS – A Practical Forward Secure Signature Scheme Based on Minimal Security Assumptions,” (full version, author’s site), 2013. Available: <a target="_blank" rel="noopener" href="https://huelsing.net/wordpress/wp-content/uploads/2013/05/mssgesamt.pdf">https://huelsing.net/wordpress/wp-content/uploads/2013/05/mssgesamt.pdf</a></li>
      <li>[6] Open Quantum Safe, “XMSS: Algorithm information,” 2025. Available: <a target="_blank" rel="noopener" href="https://openquantumsafe.org/liboqs/algorithms/sig_stfl/xmss.html">https://openquantumsafe.org/liboqs/algorithms/sig_stfl/xmss.html</a></li>
    </ol>
  </div>
  </main>
</body>
</html>

