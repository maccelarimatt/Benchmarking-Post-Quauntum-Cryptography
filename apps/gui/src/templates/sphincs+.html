<!DOCTYPE html>
<html lang="en">
<head>
  {% from '_background_effects.html' import background_layer, background_rules %}
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>{{ label }} - Details</title>
  <link rel="icon" href="/static/favicon.svg" type="image/svg+xml" sizes="any" />
  <link rel="mask-icon" href="/static/favicon.svg" color="#1fb6b8" />
  <link rel="apple-touch-icon" href="/static/Images/pqc-bench-logo.png" />
  <meta name="theme-color" content="#0b0f14" />
  <style>
    /* Dark scrollbar styling */
    html {
      scrollbar-width: thin;
      scrollbar-color: rgba(36, 49, 63, 0.85) rgba(7, 11, 17, 0.92);
    }
    html::-webkit-scrollbar {
      width: 12px;
      height: 12px;
    }
    html::-webkit-scrollbar-track {
      background: rgba(7, 11, 17, 0.92);
    }
    html::-webkit-scrollbar-thumb {
      background: rgba(148, 163, 184, 0.45);
      border-radius: 999px;
      border: 2px solid rgba(7, 11, 17, 0.92);
    }
    html::-webkit-scrollbar-thumb:hover {
      background: rgba(148, 163, 184, 0.65);
    }

  :root { --island-bg: rgba(38,41,45,.92); --island-radius:1.5rem; --text:#fff; --accent:#1fb6b8; }
    body {
      margin:0;
      padding:5vh 5vw;
      color:var(--text);
      font-family: Inter, system-ui, -apple-system, Segoe UI, Roboto, "Helvetica Neue", Arial, sans-serif;
      background:
        radial-gradient(circle at 15% 20%, rgba(31, 182, 184, 0.16), transparent 55%),
        radial-gradient(circle at 80% 15%, rgba(77, 157, 255, 0.12), transparent 60%),
        linear-gradient(180deg, #070b11 0%, #04070c 60%, #020408 100%);
      position: relative;
    }
    .island { background:var(--island-bg); border-radius:var(--island-radius); padding:1.25rem; backdrop-filter: blur(4px); max-width: 1000px; margin:0 auto 1.6vh auto; }
    .btn, button, input[type="submit"], input[type="button"], a.btn { padding:.65rem 1.4rem; border:none; border-radius:.7rem; background: var(--accent); color:#fff; cursor:pointer; box-shadow: 0 4px 14px rgba(31,182,184,.25); text-decoration:none; transition: background-color .2s ease, filter .15s ease, box-shadow .2s ease; }
    .btn:hover, button:hover, input[type="submit"]:hover, input[type="button"]:hover, a.btn:hover { filter: brightness(0.92); box-shadow: 0 6px 18px rgba(31,182,184,.32); }
    .badge { font-size:.9rem; background:rgba(255,255,255,.2); padding:.2rem .6rem; border-radius:.4rem; display:inline-block; }
    .muted { opacity:.9; }
    h2, h3 { margin: 0 0 .6rem 0; }
    h2 { font-size:1.25rem; }
    h3 { font-size:1.05rem; margin-top:1.2rem; }
    .grid-2 { display:grid; grid-template-columns:1fr 1fr; gap:1rem; }
    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; }
    table { width:100%; border-collapse:collapse; }
    th, td { text-align:left; padding:.45rem .4rem; border-bottom:1px solid rgba(255,255,255,.2); }
    th { font-weight:600; }
    .refs li { margin:.35rem 0; }
    .chip { display:inline-block; font-size:.85rem; padding:.1rem .5rem; border-radius:.4rem; background:rgba(255,255,255,.15); margin-right:.4rem; }
    .toc a { color:#fff; text-decoration:none; }
    .toc a:hover { text-decoration:underline; }
    .note { font-size:.95rem; opacity:.95; }
    code { background: rgba(255,255,255,.12); padding:.05rem .3rem; border-radius:.3rem; }
    ol.refs { list-style: none; margin: 0; padding-left: 0; }
    {{ background_rules() | safe }}
  </style>
  <!-- MathJax for LaTeX-style math -->
  <script async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
</head>
<body>
  {{ background_layer() }}
<div class="island" style="display:flex; justify-content:space-between; align-items:center; margin-bottom:2vh;">
    <div>
      <div style="font-size:1.6rem; font-weight:700;">{{ label }}</div>
      {% if kind %}<div class="badge" title="Kind">{{ kind }}</div>{% endif %}
    </div>
    <div>
      <a href="/" class="btn">Back to home</a>
    </div>
  </div>

  <div class="island">
    <div style="font-weight:700; margin-bottom:.5rem;">About</div>
    <p class="muted">
      {{ about or 'This page explains the SPHINCS+ / SLH-DSA hash-based signature in depth: its origins, math, parameters, algorithms, security assumptions, and practical considerations—plus references.' }}
    </p>
    <div class="toc muted">
      <span class="chip"><a href="#history">Origins & history</a></span>
      <span class="chip"><a href="#overview">Design overview</a></span>
      <span class="chip"><a href="#math">Mathematical setting</a></span>
      <span class="chip"><a href="#params">Parameter sets</a></span>
      <span class="chip"><a href="#algorithms">Algorithms</a></span>
      <span class="chip"><a href="#security">Security</a></span>
      <span class="chip"><a href="#impl">Implementation notes</a></span>
      <span class="chip"><a href="#proscons">Pros & cons</a></span>
      <span class="chip"><a href="#references">References</a></span>
    </div>
  </div>

  <div class="island" id="history">
    <h2>Origins & history</h2>
    <p class="muted">
      <strong>SPHINCS+</strong> is a stateless, hash-based signature framework that improves on SPHINCS (EUROCRYPT 2015) by
      reducing signature sizes and clarifying security. In <b>August 2024</b>, NIST standardised SPHINCS+ as
      <em>FIPS&nbsp;205: Stateless Hash-Based Digital Signature Standard (SLH-DSA)</em>, with SHA-2- and SHAKE-based
      families and “small” (s) vs “fast” (f) trade-offs; there are twelve approved parameter sets. SPHINCS+ remains
      attractive as it relies only on the preimage/collision resistance of standard hash functions. [1][5][9]
    </p>
  </div>

  <div class="island" id="overview">
    <h2>Design overview</h2>
    <p class="muted">
      SPHINCS+ composes three hash-based primitives:
      <em>FORS</em> (a forest of small Merkle trees) to sign a message digest,
      <em>WOTS+</em> (Winternitz one-time signatures) to authenticate sub-roots,
      and a <em>hypertree</em> (a stack of Merkle trees) to authenticate the chain to the public root.
      Keys are seeds for PRFs and for deriving one-time keys; signatures contain a FORS proof and
      <em>d</em> layers of WOTS+ signatures with Merkle authentication paths. [3][4][6]
    </p>
  </div>

  <div class="island" id="math">
    <h2>Mathematical setting</h2>
    <p class="muted">
      Let \(n\in\{16,24,32\}\) be the security parameter (bytes). SPHINCS+ works over tweakable hash families
      \(F,H,T\) built from either SHA-256 or SHAKE-256 and an <em>address</em> (ADR) that domain-separates calls.
      A deterministic/hedged randomness value \(R\) is derived per signature; the message representative and addressing
      indices come from a randomised hash \(\mathrm{H}_{\text{msg}}\).
    </p>
    <p class="mono">
      \( R = \mathrm{PRF}_{\mathsf{sk\_prf}}(\mathrm{opt\_rand}, M),\quad (\text{digest},\ \text{idx\_tree},\ \text{idx\_leaf}) = \mathrm{H}_{\text{msg}}(R, \mathrm{pk}, M). \)
    </p>
    <h3>FORS (k small trees of height a)</h3>
    <p class="muted">
      Split <span class="mono">digest</span> into \(k\) indices \(i_1,\ldots,i_k\in\{0,\ldots,2^a-1\}\).
      For each \(j\), sign by revealing the secret leaf and the auth path to the FORS tree root \(r_j\); set
    </p>
    <p class="mono">
      \( r_{\text{FORS}} = H(r_1\|r_2\|\cdots\|r_k). \)
    </p>
    <h3>WOTS+ and Merkle hypertree</h3>
    <p class="muted">
      WOTS+ signs \(r_{\text{FORS}}\) at the bottom layer (leaf <span class="mono">idx_leaf</span> inside tree <span class="mono">idx_tree</span>), then its public key
      is authenticated up a Merkle tree. The resulting root becomes the “message” for the next layer, iterated over
      \(d\) layers to reach the public root \( \mathsf{PK.root} \).
    </p>
    <p class="mono">
      \(\text{WOTS chain: } X_{j,t+1} = F_{\text{ADR}}(X_{j,t}),\quad t=0,\ldots,w-2,\)
    </p>
    <p class="muted">
      where each coordinate \(X_j\) advances \(b_j\) steps according to the base-\(w\) encoding of the input.
    </p>
  </div>

  <div class="island" id="params">
    <h2>Parameter sets (SLH-DSA families)</h2>
    <p class="muted note">
      Twelve standardised sets: {SHA2, SHAKE} × {128, 192, 256} × {s (small), f (fast)}.
      Typical internal parameters include \(n\) (bytes), total tree height \(h\), layers \(d\), Winternitz \(w\),
      FORS trees \(k\) of height \(a\). Keys are compact; signatures are large (trade-offs vary by “s/f”). [1][3][7][11]
    </p>
    <div class="grid-2">
      <div>
        <h3>Sizes (bytes)</h3>
        <table>
          <thead><tr><th>Parameter set</th><th>PK</th><th>SK</th><th>Signature</th><th>NIST level</th></tr></thead>
          <tbody>
            <tr><td>SPHINCS+-SHA2-128s</td><td>32</td><td>64</td><td>7 856</td><td>1</td></tr>
            <tr><td>SPHINCS+-SHA2-128f</td><td>32</td><td>64</td><td>17 088</td><td>1</td></tr>
            <tr><td>SPHINCS+-SHA2-192s</td><td>48</td><td>96</td><td>16 224</td><td>3</td></tr>
            <tr><td>SPHINCS+-SHA2-192f</td><td>48</td><td>96</td><td>35 664</td><td>3</td></tr>
            <tr><td>SPHINCS+-SHA2-256s</td><td>64</td><td>128</td><td>29 792</td><td>5</td></tr>
            <tr><td>SPHINCS+-SHA2-256f</td><td>64</td><td>128</td><td>49 856</td><td>5</td></tr>
          </tbody>
        </table>
        <p class="muted" style="margin-top:.5rem;">SHAKE variants have the same sizes. See also the SLH-DSA OIDs defined for all 12 sets. [7][11]</p>
      </div>
      <div class="muted">
        <h3>Key structure</h3>
        <ul>
          <li>\(\mathrm{sk}=(\mathsf{sk\_seed},\,\mathsf{sk\_prf},\,\mathsf{pk\_seed},\,\mathsf{PK.root})\)</li>
          <li>\(\mathrm{pk}=(\mathsf{pk\_seed},\,\mathsf{PK.root})\)</li>
          <li>Seeds derive all one-time keys and masks via ADR-tweaked hashes. [3][5]</li>
        </ul>
      </div>
    </div>
  </div>

  <div class="island" id="algorithms">
    <h2>Algorithms</h2>

    <h3>Key generation</h3>
    <p class="muted">
      Sample \( \mathsf{sk\_seed}, \mathsf{sk\_prf}, \mathsf{pk\_seed}\gets\{0,1\}^{8n} \).
      Compute \( \mathsf{PK.root} \) by building the hypertree top root from seeds (no messages involved).
    </p>
    <p class="mono">
      \( \mathrm{sk}=(\mathsf{sk\_seed},\mathsf{sk\_prf},\mathsf{pk\_seed},\mathsf{PK.root}),\quad \mathrm{pk}=(\mathsf{pk\_seed},\mathsf{PK.root}). \)
    </p>

    <h3>Signing (deterministic/hedged)</h3>
    <p class="muted">
      For message \(M\) and optional randomness \( \mathrm{opt\_rand}\):
    </p>
    <ol class="muted">
      <li>Compute \( R = \mathrm{PRF}_{\mathsf{sk\_prf}}(\mathrm{opt\_rand}, M) \).</li>
      <li>Compute \((\text{digest},\text{idx\_tree},\text{idx\_leaf})=\mathrm{H}_{\text{msg}}(R,\mathrm{pk},M)\).</li>
      <li><b>FORS sign:</b> produce \( \sigma_{\text{FORS}} \) and \( r_{\text{FORS}} \) from <span class="mono">digest</span>.</li>
      <li><b>Hypertree auth:</b> for each layer \(i=0,\ldots,d-1\): WOTS+-sign the previous root and include the Merkle auth path to the next root.</li>
    </ol>
    <p class="muted">
      Signature \( \sigma = (R,\ \sigma_{\text{FORS}},\ \{\sigma^{(i)}_{\text{WOTS}},\text{AuthPath}^{(i)}\}_{i=0}^{d-1}) \). [3][5]
    </p>

    <h3>Verification</h3>
    <ol class="muted">
      <li>Recompute \((\text{digest},\text{idx\_tree},\text{idx\_leaf})=\mathrm{H}_{\text{msg}}(R,\mathrm{pk},M)\).</li>
      <li>Verify \( \sigma_{\text{FORS}} \) to obtain \( r_{\text{FORS}} \).</li>
      <li>Iteratively verify WOTS+ at each layer and climb the Merkle paths to reconstruct the final root \( r^* \).</li>
    </ol>
    <p class="muted">Accept iff \( r^* = \mathsf{PK.root} \) and all component checks pass. [3]</p>
  </div>

  <div class="island" id="security">
    <h2>Security at a glance</h2>
    <ul class="muted">
      <li><b>Assumptions:</b> security reduces to standard hash-function properties (preimage, second-preimage, collision resistance); no lattice/code assumptions. [3][4]</li>
      <li><b>Stateless:</b> no per-device state to manage (unlike XMSS/LMS), avoiding reuse risks at scale. [3]</li>
      <li><b>Domain separation:</b> FIPS 205 clarifies message-vs-prehash modes with explicit domain-separated inputs. [5]</li>
      <li><b>Categories:</b> 128/192/256-bit families target NIST levels 1/3/5; “s” minimises signature size, “f” speeds signing. [1][3]</li>
    </ul>
  </div>

  <div class="island" id="impl">
    <h2>Implementation notes</h2>
    <ul class="muted">
      <li><b>Primitives:</b> SHA-256 or SHAKE-256; all hashing is address-tweaked for domain separation and multi-target security. [3][5]</li>
      <li><b>Memory/streaming:</b> Hypertree authentication can be streamed; verification works in small RAM (kB-scale) on embedded devices. [13]</li>
      <li><b>Performance:</b> Verification is comparatively fast; signing cost depends on “s/f” and hardware acceleration (Keccak cores help). [8][12]</li>
      <li><b>Interoperability:</b> X.509/CMS OIDs defined for the 12 SLH-DSA sets; major TLS/PKI stacks are adding support. [11]</li>
    </ul>
  </div>

  <div class="island" id="proscons">
    <h2>Pros & cons</h2>
    <div class="grid-2">
      <div>
        <h3>Pros</h3>
        <ul class="muted">
          <li>Conservative assumptions (hash-only); diverse fallback to lattice/code-based suites. [3][5]</li>
          <li>Stateless and simple to implement/review; robust against quantum attacks by design. [1][3]</li>
          <li>Small public/secret keys (tens of bytes). [7]</li>
        </ul>
      </div>
      <div>
        <h3>Cons</h3>
        <ul class="muted">
          <li>Large signatures (≈8–50&nbsp;KB) compared to ML-DSA/Falcon; bandwidth/storage overhead. [7]</li>
          <li>Signing is CPU-intensive for “s” sets; careful parameter choice needed for throughput-sensitive systems. [3][7]</li>
        </ul>
      </div>
    </div>
  </div>

  <div class="island" id="references">
    <h2>References</h2>
    <ol class="refs muted">
      <li>[1] NIST, “<i>FIPS 205: Stateless Hash-Based Digital Signature Standard (SLH-DSA)</i>,” Aug. 13, 2024. [Online]. Available: <a target="_blank" rel="noopener" href="https://csrc.nist.gov/pubs/fips/205/final">csrc.nist.gov/pubs/fips/205/final</a></li>
      <li>[2] Federal Register, “Announcing issuance of FIPS 203/204/205,” Aug. 14, 2024. [Online]. Available: <a target="_blank" rel="noopener" href="https://www.federalregister.gov/documents/2024/08/14/2024-17956/announcing-issuance-of-federal-information-processing-standards-fips-fips-203-module-lattice-based">federalregister.gov</a></li>
      <li>[3] J. Aumasson <i>et&nbsp;al.</i>, “<i>SPHINCS+ Specification (Round 3 / r3.1)</i>,” 2020–2022. [Online]. Available: <a target="_blank" rel="noopener" href="https://sphincs.org/data/sphincs%2B-r3.1-specification.pdf">sphincs.org</a></li>
      <li>[4] D. J. Bernstein <i>et&nbsp;al.</i>, “<i>SPHINCS+: Stateless Hash-Based Signatures</i>,” 2019 (paper). [Online]. Available: <a target="_blank" rel="noopener" href="https://sphincs.org/data/sphincs%2B-paper.pdf">sphincs.org</a></li>
      <li>[5] NIST, “<i>FIPS 205 (PDF)</i>,” domain separation and algorithm details. [Online]. Available: <a target="_blank" rel="noopener" href="https://nvlpubs.nist.gov/nistpubs/fips/nist.fips.205.pdf">nist.gov</a></li>
      <li>[6] NIST PQC, “Official comments / design notes (Round 3),” 2021. [Online]. Available: <a target="_blank" rel="noopener" href="https://csrc.nist.gov/csrc/media/Projects/post-quantum-cryptography/documents/round-3/official-comments/Sphincs-Plus-round3-official-comment.pdf">csrc.nist.gov</a></li>
      <li>[7] Open Quantum Safe, “SPHINCS+ parameter set summary (sizes),” accessed Sep. 14, 2
