<!DOCTYPE html>
<html lang="en">
<head>
  {% from '_background_effects.html' import background_layer, background_rules %}
  {% from '_detail_styles.html' import detail_styles %}
  {% from '_header.html' import header_styles, render_header %}
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>{{ label }} - Details</title>
  <link rel="icon" href="/static/favicon.svg" type="image/svg+xml" sizes="any" />
  <link rel="mask-icon" href="/static/favicon.svg" color="#1fb6b8" />
  <link rel="apple-touch-icon" href="/static/Images/pqc-bench-logo.png" />
  <meta name="theme-color" content="#0b0f14" />
  <style>
    {{ detail_styles() | safe }}
    {{ header_styles() | safe }}
    {{ background_rules() | safe }}
  </style>
  <!-- MathJax for LaTeX-style math -->
  <script async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
</head>
<body>
  {{ background_layer() }}
  {{ render_header(active='benchmarking') }}
  <main class="detail-shell">
    <div class="island detail-hero">
      <div class="detail-hero__text">
        <span class="detail-hero__eyebrow">Algorithm Profile</span>
        <h1 class="detail-hero__title">{{ label }}</h1>
        <div class="detail-hero__meta">
          {% if kind %}<span class="detail-pill">{{ kind }}</span>{% endif %}
        </div>
        <p class="detail-hero__lead">
          {{ hero_lead or ('Explore the design, math, and security posture of ' ~ label ~ ' in depth.') }}
        </p>
      </div>
      <div class="detail-hero__actions">
        <a href="/" class="btn btn-soft">Back to home</a>
        <a href="#overview" class="btn btn-ghost">Jump to overview</a>
      </div>
    </div>

  <div class="island">
    <h2>About</h2>
    <p class="muted">
      {{ about or 'This page explains the SPHINCS+ / SLH-DSA hash-based signature in depth: its origins, math, parameters, algorithms, security assumptions, and practical considerations—plus references.' }}
    </p>
    <div class="toc muted">
      <span class="chip"><a href="#history">Origins & history</a></span>
      <span class="chip"><a href="#overview">Design overview</a></span>
      <span class="chip"><a href="#math">Mathematical setting</a></span>
      <span class="chip"><a href="#params">Parameter sets</a></span>
      <span class="chip"><a href="#algorithms">Algorithms</a></span>
      <span class="chip"><a href="#security">Security</a></span>
      <span class="chip"><a href="#impl">Implementation notes</a></span>
      <span class="chip"><a href="#proscons">Pros & cons</a></span>
      <span class="chip"><a href="#references">References</a></span>
    </div>
  </div>

  <div class="island" id="history">
    <h2>Origins & history</h2>
    <p class="muted">
      <strong>SPHINCS+</strong> is a stateless, hash-based signature framework that improves on SPHINCS (EUROCRYPT 2015) by
      reducing signature sizes and clarifying security. In <b>August 2024</b>, NIST standardised SPHINCS+ as
      <em>FIPS&nbsp;205: Stateless Hash-Based Digital Signature Standard (SLH-DSA)</em>, with SHA-2- and SHAKE-based
      families and “small” (s) vs “fast” (f) trade-offs; there are twelve approved parameter sets. SPHINCS+ remains
      attractive as it relies only on the preimage/collision resistance of standard hash functions. [1][5][9]
    </p>
  </div>

  <div class="island" id="overview">
    <h2>Design overview</h2>
    <p class="muted">
      SPHINCS+ composes three hash-based primitives:
      <em>FORS</em> (a forest of small Merkle trees) to sign a message digest,
      <em>WOTS+</em> (Winternitz one-time signatures) to authenticate sub-roots,
      and a <em>hypertree</em> (a stack of Merkle trees) to authenticate the chain to the public root.
      Keys are seeds for PRFs and for deriving one-time keys; signatures contain a FORS proof and
      <em>d</em> layers of WOTS+ signatures with Merkle authentication paths. [3][4][6]
    </p>
  </div>

  <div class="island" id="math">
    <h2>Mathematical setting</h2>
    <p class="muted">
      Let \(n\in\{16,24,32\}\) be the security parameter (bytes). SPHINCS+ works over tweakable hash families
      \(F,H,T\) built from either SHA-256 or SHAKE-256 and an <em>address</em> (ADR) that domain-separates calls.
      A deterministic/hedged randomness value \(R\) is derived per signature; the message representative and addressing
      indices come from a randomised hash \(\mathrm{H}_{\text{msg}}\).
    </p>
    <p class="mono">
      \( R = \mathrm{PRF}_{\mathsf{sk\_prf}}(\mathrm{opt\_rand}, M),\quad (\text{digest},\ \text{idx\_tree},\ \text{idx\_leaf}) = \mathrm{H}_{\text{msg}}(R, \mathrm{pk}, M). \)
    </p>
    <h3>FORS (k small trees of height a)</h3>
    <p class="muted">
      Split <span class="mono">digest</span> into \(k\) indices \(i_1,\ldots,i_k\in\{0,\ldots,2^a-1\}\).
      For each \(j\), sign by revealing the secret leaf and the auth path to the FORS tree root \(r_j\); set
    </p>
    <p class="mono">
      \( r_{\text{FORS}} = H(r_1\|r_2\|\cdots\|r_k). \)
    </p>
    <h3>WOTS+ and Merkle hypertree</h3>
    <p class="muted">
      WOTS+ signs \(r_{\text{FORS}}\) at the bottom layer (leaf <span class="mono">idx_leaf</span> inside tree <span class="mono">idx_tree</span>), then its public key
      is authenticated up a Merkle tree. The resulting root becomes the “message” for the next layer, iterated over
      \(d\) layers to reach the public root \( \mathsf{PK.root} \).
    </p>
    <p class="mono">
      \(\text{WOTS chain: } X_{j,t+1} = F_{\text{ADR}}(X_{j,t}),\quad t=0,\ldots,w-2,\)
    </p>
    <p class="muted">
      where each coordinate \(X_j\) advances \(b_j\) steps according to the base-\(w\) encoding of the input.
    </p>
  </div>

  <div class="island" id="params">
    <h2>Parameter sets (SLH-DSA families)</h2>
    <p class="muted note">
      Twelve standardised sets: {SHA2, SHAKE} × {128, 192, 256} × {s (small), f (fast)}.
      Typical internal parameters include \(n\) (bytes), total tree height \(h\), layers \(d\), Winternitz \(w\),
      FORS trees \(k\) of height \(a\). Keys are compact; signatures are large (trade-offs vary by “s/f”). [1][3][7][11]
    </p>
    <div class="grid-2">
      <div>
        <h3>Sizes (bytes)</h3>
        <table>
          <thead><tr><th>Parameter set</th><th>PK</th><th>SK</th><th>Signature</th><th>NIST level</th></tr></thead>
          <tbody>
            <tr><td>SPHINCS+-SHA2-128s</td><td>32</td><td>64</td><td>7 856</td><td>1</td></tr>
            <tr><td>SPHINCS+-SHA2-128f</td><td>32</td><td>64</td><td>17 088</td><td>1</td></tr>
            <tr><td>SPHINCS+-SHA2-192s</td><td>48</td><td>96</td><td>16 224</td><td>3</td></tr>
            <tr><td>SPHINCS+-SHA2-192f</td><td>48</td><td>96</td><td>35 664</td><td>3</td></tr>
            <tr><td>SPHINCS+-SHA2-256s</td><td>64</td><td>128</td><td>29 792</td><td>5</td></tr>
            <tr><td>SPHINCS+-SHA2-256f</td><td>64</td><td>128</td><td>49 856</td><td>5</td></tr>
          </tbody>
        </table>
        <p class="muted" style="margin-top:.5rem;">SHAKE variants have the same sizes. See also the SLH-DSA OIDs defined for all 12 sets. [7][11]</p>
      </div>
      <div class="muted">
        <h3>Key structure</h3>
        <ul>
          <li>\(\mathrm{sk}=(\mathsf{sk\_seed},\,\mathsf{sk\_prf},\,\mathsf{pk\_seed},\,\mathsf{PK.root})\)</li>
          <li>\(\mathrm{pk}=(\mathsf{pk\_seed},\,\mathsf{PK.root})\)</li>
          <li>Seeds derive all one-time keys and masks via ADR-tweaked hashes. [3][5]</li>
        </ul>
      </div>
    </div>
  </div>

  <div class="island" id="algorithms">
    <h2>Algorithms</h2>

    <h3>Key generation</h3>
    <p class="muted">
      Sample \( \mathsf{sk\_seed}, \mathsf{sk\_prf}, \mathsf{pk\_seed}\gets\{0,1\}^{8n} \).
      Compute \( \mathsf{PK.root} \) by building the hypertree top root from seeds (no messages involved).
    </p>
    <p class="mono">
      \( \mathrm{sk}=(\mathsf{sk\_seed},\mathsf{sk\_prf},\mathsf{pk\_seed},\mathsf{PK.root}),\quad \mathrm{pk}=(\mathsf{pk\_seed},\mathsf{PK.root}). \)
    </p>

    <h3>Signing (deterministic/hedged)</h3>
    <p class="muted">
      For message \(M\) and optional randomness \( \mathrm{opt\_rand}\):
    </p>
    <ol class="muted">
      <li>Compute \( R = \mathrm{PRF}_{\mathsf{sk\_prf}}(\mathrm{opt\_rand}, M) \).</li>
      <li>Compute \((\text{digest},\text{idx\_tree},\text{idx\_leaf})=\mathrm{H}_{\text{msg}}(R,\mathrm{pk},M)\).</li>
      <li><b>FORS sign:</b> produce \( \sigma_{\text{FORS}} \) and \( r_{\text{FORS}} \) from <span class="mono">digest</span>.</li>
      <li><b>Hypertree auth:</b> for each layer \(i=0,\ldots,d-1\): WOTS+-sign the previous root and include the Merkle auth path to the next root.</li>
    </ol>
    <p class="muted">
      Signature \( \sigma = (R,\ \sigma_{\text{FORS}},\ \{\sigma^{(i)}_{\text{WOTS}},\text{AuthPath}^{(i)}\}_{i=0}^{d-1}) \). [3][5]
    </p>

    <h3>Verification</h3>
    <ol class="muted">
      <li>Recompute \((\text{digest},\text{idx\_tree},\text{idx\_leaf})=\mathrm{H}_{\text{msg}}(R,\mathrm{pk},M)\).</li>
      <li>Verify \( \sigma_{\text{FORS}} \) to obtain \( r_{\text{FORS}} \).</li>
      <li>Iteratively verify WOTS+ at each layer and climb the Merkle paths to reconstruct the final root \( r^* \).</li>
    </ol>
    <p class="muted">Accept iff \( r^* = \mathsf{PK.root} \) and all component checks pass. [3]</p>
  </div>

  <div class="island" id="security">
    <h2>Security at a glance</h2>
    <ul class="muted">
      <li><b>Assumptions:</b> security reduces to standard hash-function properties (preimage, second-preimage, collision resistance); no lattice/code assumptions. [3][4]</li>
      <li><b>Stateless:</b> no per-device state to manage (unlike XMSS/LMS), avoiding reuse risks at scale. [3]</li>
      <li><b>Domain separation:</b> FIPS 205 clarifies message-vs-prehash modes with explicit domain-separated inputs. [5]</li>
      <li><b>Categories:</b> 128/192/256-bit families target NIST levels 1/3/5; “s” minimises signature size, “f” speeds signing. [1][3]</li>
    </ul>
  </div>

  <div class="island" id="impl">
    <h2>Implementation notes</h2>
    <ul class="muted">
      <li><b>Primitives:</b> SHA-256 or SHAKE-256; all hashing is address-tweaked for domain separation and multi-target security. [3][5]</li>
      <li><b>Memory/streaming:</b> Hypertree authentication can be streamed; verification works in small RAM (kB-scale) on embedded devices. [13]</li>
      <li><b>Performance:</b> Verification is comparatively fast; signing cost depends on “s/f” and hardware acceleration (Keccak cores help). [8][12]</li>
      <li><b>Interoperability:</b> X.509/CMS OIDs defined for the 12 SLH-DSA sets; major TLS/PKI stacks are adding support. [11]</li>
    </ul>
  </div>

  <div class="island" id="proscons">
    <h2>Pros & cons</h2>
    <div class="grid-2">
      <div>
        <h3>Pros</h3>
        <ul class="muted">
          <li>Conservative assumptions (hash-only); diverse fallback to lattice/code-based suites. [3][5]</li>
          <li>Stateless and simple to implement/review; robust against quantum attacks by design. [1][3]</li>
          <li>Small public/secret keys (tens of bytes). [7]</li>
        </ul>
      </div>
      <div>
        <h3>Cons</h3>
        <ul class="muted">
          <li>Large signatures (≈8–50&nbsp;KB) compared to ML-DSA/Falcon; bandwidth/storage overhead. [7]</li>
          <li>Signing is CPU-intensive for “s” sets; careful parameter choice needed for throughput-sensitive systems. [3][7]</li>
        </ul>
      </div>
    </div>
  </div>

    <div class="island" id="references">
    <h2>References</h2>
    <ol class="refs muted">
      <li>[1] NIST, "<i>FIPS 205: Stateless Hash-Based Digital Signature Standard (SLH-DSA)</i>," Aug. 13, 2024. [Online]. Available: <a target="_blank" rel="noopener" href="https://csrc.nist.gov/pubs/fips/205/final">csrc.nist.gov/pubs/fips/205/final</a></li>
      <li>[2] Federal Register, "Announcing issuance of FIPS 203/204/205," Aug. 14, 2024. [Online]. Available: <a target="_blank" rel="noopener" href="https://www.federalregister.gov/documents/2024/08/14/2024-17956/announcing-issuance-of-federal-information-processing-standards-fips-fips-203-module-lattice-based">federalregister.gov</a></li>
      <li>[3] J. Aumasson <i>et&nbsp;al.</i>, "<i>SPHINCS+ Specification (Round 3 / r3.1)</i>," 2020?2022. [Online]. Available: <a target="_blank" rel="noopener" href="https://sphincs.org/data/sphincs%2B-r3.1-specification.pdf">sphincs.org</a></li>
      <li>[4] D. J. Bernstein <i>et&nbsp;al.</i>, "<i>SPHINCS+: Stateless Hash-Based Signatures</i>," 2019 (paper). [Online]. Available: <a target="_blank" rel="noopener" href="https://sphincs.org/data/sphincs%2B-paper.pdf">sphincs.org</a></li>
      <li>[5] NIST, "<i>FIPS 205 (PDF)</i>," domain separation and algorithm details. [Online]. Available: <a target="_blank" rel="noopener" href="https://nvlpubs.nist.gov/nistpubs/fips/nist.fips.205.pdf">nist.gov</a></li>
      <li>[6] NIST PQC, "Official comments / design notes (Round 3)," 2021. [Online]. Available: <a target="_blank" rel="noopener" href="https://csrc.nist.gov/csrc/media/Projects/post-quantum-cryptography/documents/round-3/official-comments/Sphincs-Plus-round3-official-comment.pdf">csrc.nist.gov</a></li>
      <li>[7] Open Quantum Safe, "SPHINCS+ parameter set summary (sizes)," accessed Sep. 14, 2024. [Online]. Available: <a target="_blank" rel="noopener" href="https://openquantumsafe.org/#sphincs-plus">openquantumsafe.org</a></li>
    </ol>
  </div>
  </main>
</body>
</html>

