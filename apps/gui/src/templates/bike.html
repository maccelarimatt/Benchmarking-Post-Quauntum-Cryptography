<!DOCTYPE html>
<html lang="en">
<head>
  {% from '_background_effects.html' import background_layer, background_rules %}
  {% from '_detail_styles.html' import detail_styles %}
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>{{ label }} - Details</title>
  <link rel="icon" href="/static/favicon.svg" type="image/svg+xml" sizes="any" />
  <link rel="mask-icon" href="/static/favicon.svg" color="#1fb6b8" />
  <link rel="apple-touch-icon" href="/static/Images/pqc-bench-logo.png" />
  <meta name="theme-color" content="#0b0f14" />
  <style>
    {{ detail_styles() | safe }}
    {{ background_rules() | safe }}
  </style>
  <!-- MathJax for LaTeX-style math -->
  <script async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
</head>
<body>
  {{ background_layer() }}
  <main class="detail-shell">
    <div class="island detail-hero">
      <div class="detail-hero__text">
        <span class="detail-hero__eyebrow">Algorithm Profile</span>
        <h1 class="detail-hero__title">{{ label }}</h1>
        <div class="detail-hero__meta">
          {% if kind %}<span class="detail-pill">{{ kind }}</span>{% endif %}
        </div>
        <p class="detail-hero__lead">
          {{ hero_lead or ('Explore the design, math, and security posture of ' ~ label ~ ' in depth.') }}
        </p>
      </div>
      <div class="detail-hero__actions">
        <a href="/" class="btn btn-soft">Back to home</a>
        <a href="#overview" class="btn btn-ghost">Jump to overview</a>
      </div>
    </div>

  <div class="island">
    <h2>About</h2>
    <p class="muted">
      {{ about or 'This page explains the BIKE (Bit-Flipping Key Encapsulation) code-based KEM: origins, design, math, parameters, algorithms, security considerations, and implementation notes—plus references.' }}
    </p>
    <div class="toc muted">
      <span class="chip"><a href="#history">Origins & history</a></span>
      <span class="chip"><a href="#overview">Design overview</a></span>
      <span class="chip"><a href="#math">Mathematical setting</a></span>
      <span class="chip"><a href="#params">Parameter sets</a></span>
      <span class="chip"><a href="#algorithms">Algorithms</a></span>
      <span class="chip"><a href="#security">Security</a></span>
      <span class="chip"><a href="#impl">Implementation notes</a></span>
      <span class="chip"><a href="#proscons">Pros & cons</a></span>
      <span class="chip"><a href="#references">References</a></span>
    </div>
  </div>

  <div class="island" id="history">
    <h2>Origins & history</h2>
    <p class="muted">
      <strong>BIKE</strong> is a code-based KEM built from QC-MDPC codes and a Niederreiter construction with
      bit-flipping (BF/BGF) decoding. BIKE advanced through the NIST PQC process as a Round-4
      candidate; in March&nbsp;2025 NIST selected HQC for standardization while continuing to study other
      code-based KEMs such as BIKE and Classic McEliece. BIKE remains a well-studied alternative with
      active implementations and ongoing analysis. [1][2]
    </p>
  </div>

  <div class="island" id="overview">
    <h2>Design overview</h2>
    <p class="muted">
      BIKE instantiates a <em>Niederreiter</em>-style KEM over the binary ring \( \mathbb{F}_2[x]/(x^r-1) \) using two weight-\(d\)
      circulant polynomials \(h_0,h_1\). The public key is a single circulant \( \hat{h}=h_1 h_0^{-1} \bmod (x^r-1) \).
      Encapsulation samples a sparse error vector \( \mathbf{e} \) of Hamming weight \(t\) and computes a ciphertext
      (a syndrome under \( \hat{h} \)) together with a key derived via KDF; decapsulation applies iterative
      bit-flipping to recover \( \mathbf{e} \), then recomputes the key. IND-CCA2 security is obtained via a Fujisaki–Okamoto-style transform
      around the CPA core. [3][4]
    </p>
  </div>

  <div class="island" id="math">
    <h2>Mathematical setting</h2>
    <p class="muted">
      Work over the cyclic code space defined by a length parameter \(2r\) via two circulant blocks. Let
      \( \mathcal{R}=\mathbb{F}_2[x]/(x^r-1) \). Secret key polynomials \(h_0,h_1\in \mathcal{R}\) have fixed weight \(d\).
    </p>
    <h3>Public/secret relation</h3>
    <p class="mono">
      \( \text{sk}=(h_0,h_1),\qquad \text{pk}=\hat{h}=h_1 h_0^{-1} \bmod (x^r-1). \)
    </p>
    <h3>Error model</h3>
    <p class="muted">
      Errors are sampled as a pair of weight-\(t\) vectors (or a degree-&lt;\(r\) polynomial with \(t\) ones) which define a
      sparse syndrome under the public parity-check relation; decoding uses thresholds derived from
      current syndrome weights and neighborhood counts in the Tanner graph. [3]
    </p>
  </div>

  <div class="island" id="params">
    <h2>Parameter sets (BIKE-L1/L3/L5)</h2>
    <p class="muted note">Three target strengths roughly align with NIST Categories 1, 3, and 5. Sizes below use the widely referenced OQS build of BIKE.</p>
    <div class="grid-2">
      <div>
        <table>
          <thead><tr><th>Set</th><th>Strength</th><th>Security model</th></tr></thead>
          <tbody>
            <tr><td>BIKE-L1</td><td>Cat-1</td><td>IND-CPA core, FO-style transform to IND-CCA2</td></tr>
            <tr><td>BIKE-L3</td><td>Cat-3</td><td>IND-CPA core, FO-style transform to IND-CCA2</td></tr>
            <tr><td>BIKE-L5</td><td>Cat-5</td><td>IND-CPA core, FO-style transform to IND-CCA2</td></tr>
          </tbody>
        </table>
        <p class="muted" style="margin-top:.5rem;">Concrete \((r,w,t)\) values and decoder thresholds are specified per versioned BIKE spec. [3]</p>
      </div>
      <div class="muted">
        <h3>Sizes (bytes)</h3>
        <table>
          <thead><tr><th>Set</th><th>Public key</th><th>Secret key</th><th>Ciphertext</th><th>Shared secret</th></tr></thead>
          <tbody>
            <tr><td>BIKE-L1</td><td>1541</td><td>5223</td><td>1573</td><td>32</td></tr>
            <tr><td>BIKE-L3</td><td>3083</td><td>10105</td><td>3115</td><td>32</td></tr>
            <tr><td>BIKE-L5</td><td>5122</td><td>16494</td><td>5154</td><td>32</td></tr>
          </tbody>
        </table>
        <p class="muted" style="margin-top:.5rem;">Representative liboqs sizes as of the cited build. [5]</p>
      </div>
    </div>
  </div>

  <div class="island" id="algorithms">
    <h2>Algorithms</h2>

    <h3>Key generation</h3>
    <p class="muted">
      Sample two length-\(r\) secret polynomials \(h_0,h_1\) of weight \(d\) (with checks to avoid weak keys).
      Compute the public key \( \hat{h}=h_1 h_0^{-1} \bmod (x^r-1) \). Optionally store auxiliary decoding data
      (thresholds, permutations) in the secret key for speed. [3][4]
    </p>

    <h3>Encapsulation (CPA core + transform)</h3>
    <p class="muted">
      Derive randomness and a message seed from input entropy; sample a weight-\(t\) error vector \( \mathbf{e} \).
      Compute the ciphertext syndrome under \( \hat{h} \) (two circulant blocks). Derive a shared secret by
      hashing \( (\mathbf{e} \,\|\, \text{ct}) \) via a KDF. Apply FO-style hashing to bind randomness and achieve CCA
      security. [3]
    </p>

    <h3>Decapsulation</h3>
    <p class="muted">
      Use bit-flipping to decode the received ciphertext back to \( \mathbf{e} \) with a bounded decryption-failure rate
      (DFR); recompute/verify the FO checks; output the shared secret or a fallback key if verification fails. [3][4]
    </p>
  </div>

  <div class="island" id="security">
    <h2>Security at a glance</h2>
    <ul class="muted">
      <li><b>Assumptions:</b> Decoding random QC-MDPC codes near capacity; syndrome decoding believed hard for chosen parameters. [3]</li>
      <li><b>Categories:</b> BIKE-L1 → Cat-1, BIKE-L3 → Cat-3, BIKE-L5 → Cat-5 (claimed). [3][5]</li>
      <li><b>CCA transform:</b> Fujisaki–Okamoto-style wrapping of the CPA scheme. [3]</li>
      <li><b>DFR & weak-key considerations:</b> Parameter/decoder choices target negligible DFR; literature discusses weak-key classes and mitigations (key filtering, domain separation, re-enc). [2][4]</li>
      <li><b>NIST status:</b> Not selected for standardization in Round-4 (HQC selected); still under study as a code-based alternative. [1][2]</li>
    </ul>
  </div>

  <div class="island" id="impl">
    <h2>Implementation notes</h2>
    <ul class="muted">
      <li><b>Symmetric primitives:</b> SHAKE or SHA-2 based hashing + KDFs depending on build; constant-time bit-flipping loops recommended. [3]</li>
      <li><b>Decoders:</b> Thresholded BF/BGF with iteration caps; vectorized popcount and carry-less multiply (PCLMUL) improve throughput. [5][6]</li>
      <li><b>API ecosystems:</b> Prototypes exist in liboqs with OpenSSL provider integrations for TLS/X.509 experiments. [5][7]</li>
      <li><b>Hardening:</b> Validate ciphertext structure, cap iterations, use key-confirmation, and enforce weak-key filters during keygen. [3][4]</li>
    </ul>
  </div>

  <div class="island" id="proscons">
    <h2>Pros & cons</h2>
    <div class="grid-2">
      <div>
        <h3>Pros</h3>
        <ul class="muted">
          <li>Compact public keys (≈1.5–5.1 KB) and ciphertexts (≈1.6–5.1 KB); good for bandwidth-sensitive links. [5]</li>
          <li>Simple arithmetic over \( \mathbb{F}_2 \) with efficient bit-slicing and hardware intrinsics; fast decapsulation on CPUs. [5][6]</li>
          <li>Long history of code-based cryptanalysis guiding conservative choices. [3]</li>
        </ul>
      </div>
      <div>
        <h3>Cons</h3>
        <ul class="muted">
          <li>Decapsulation has a non-zero DFR; implementations must include robust re-enc/confirmation logic. [3]</li>
          <li>Ongoing research into weak-key structure and parameter margins; not standardized by NIST (as of 2025). [2]</li>
        </ul>
      </div>
    </div>
  </div>

  <div class="island" id="references">
    <h2>References</h2>
    <ol class="refs muted">
      <li>[1] NIST, “<i>Status Report on the Fourth Round of the NIST PQC Standardization Process (NIST IR 8545)</i>,” Mar. 2025. <a target="_blank" rel="noopener" href="https://csrc.nist.gov/pubs/ir/8545/final">nist.gov</a></li>
      <li>[2] NIST PQC Seminars, “<i>BIKE: Bit-flipping Key Encapsulation</i>,” Sep. 27, 2024. <a target="_blank" rel="noopener" href="https://csrc.nist.gov/csrc/media/Projects/post-quantum-cryptography/documents/pqc-seminars/presentations/21-bike-09272024.pdf">csrc.nist.gov</a></li>
      <li>[3] BIKE Team, “<i>BIKE Specification</i>,” v5.x (QC-MDPC Niederreiter KEM, FO transform). <a target="_blank" rel="noopener" href="https://bikesuite.org/files/v4.2/BIKE_Spec.2021.07.26.1.pdf">bikesuite.org</a></li>
      <li>[4] Drucker, Gueron, Kostic, “<i>A lean BIKE KEM design for ephemeral key agreement</i>,” NIST PQC 2024. <a target="_blank" rel="noopener" href="https://csrc.nist.gov/csrc/media/Events/2024/fifth-pqc-standardization-conference/documents/papers/a-lean-bike-kem.pdf">nist.gov</a></li>
      <li>[5] Open Quantum Safe, “<i>BIKE in liboqs (sizes & profiles)</i>.” <a target="_blank" rel="noopener" href="https://openquantumsafe.org/liboqs/algorithms/kem/bike.html">openquantumsafe.org</a></li>
      <li>[6] AWS Labs, “<i>Additional optimized BIKE implementation</i>.” <a target="_blank" rel="noopener" href="https://github.com/awslabs/bike-kem">github.com/awslabs/bike-kem</a></li>
      <li>[7] Open Quantum Safe, “<i>liboqs</i> (OpenSSL provider, TLS/X.509 demos).” <a target="_blank" rel="noopener" href="https://github.com/open-quantum-safe/liboqs">github.com/open-quantum-safe/liboqs</a></li>
    </ol>
  </div>
  </main>
</body>
</html>

